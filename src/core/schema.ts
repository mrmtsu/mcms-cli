export type SchemaBundle = {
  version: "0.x";
  pulledAt: string;
  serviceDomain: string | null;
  apis: Array<{
    endpoint: string;
    api: unknown;
  }>;
};

type ApiListItem = {
  endpoint?: unknown;
  apiId?: unknown;
  id?: unknown;
};

type ApiField = {
  fieldId?: unknown;
  required?: unknown;
  kind?: unknown;
  type?: unknown;
  fieldType?: unknown;
  inputType?: unknown;
  multiple?: unknown;
  isMultiple?: unknown;
  selectItems?: unknown;
  options?: unknown;
};

type NormalizedApiSchema = {
  endpoint: string;
  api: unknown;
};

export type GeneratedTypesResult = {
  code: string;
  endpointCount: number;
  warnings: string[];
};

export function buildSchemaBundle(params: {
  serviceDomain?: string;
  apis: Array<{ endpoint: string; api: unknown }>;
}): SchemaBundle {
  return {
    version: "0.x",
    pulledAt: new Date().toISOString(),
    serviceDomain: params.serviceDomain ?? null,
    apis: params.apis,
  };
}

export function extractApiEndpoints(data: unknown): string[] {
  const items = extractApiListItems(data);
  const endpoints = items
    .map((item) => extractEndpointName(item))
    .filter((value): value is string => value !== null);

  return [...new Set(endpoints)].sort((a, b) => a.localeCompare(b));
}

export function generateTypesFromSchema(input: unknown): GeneratedTypesResult {
  const schemas = normalizeSchemas(input);
  const warnings: string[] = [];

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/**");
  lines.push(" * Generated by mcms-cli types generate");
  lines.push(" * Do not edit manually.");
  lines.push(" */");
  lines.push("");

  const endpointMap: Array<{ endpoint: string; typeName: string }> = [];
  const usedTypeNames = new Set<string>();

  for (const schema of schemas) {
    const typeName = uniqueTypeName(`${toPascalCase(schema.endpoint)}Content`, usedTypeNames);
    usedTypeNames.add(typeName);
    endpointMap.push({ endpoint: schema.endpoint, typeName });

    const fields = extractApiFields(schema.api);
    if (fields.length === 0) {
      warnings.push(`No fields found for endpoint: ${schema.endpoint}`);
    }

    lines.push(`export interface ${typeName} {`);
    lines.push("  id?: string;");

    const seenFields = new Set<string>();
    for (const field of fields) {
      const fieldId = normalizeString(field.fieldId);
      if (!fieldId) {
        continue;
      }

      if (seenFields.has(fieldId)) {
        continue;
      }
      seenFields.add(fieldId);

      const propertyName = isTsIdentifier(fieldId) ? fieldId : JSON.stringify(fieldId);
      const optional = isFieldRequired(field) ? "" : "?";
      const propertyType = inferTsType(field);
      lines.push(`  ${propertyName}${optional}: ${propertyType};`);
    }

    lines.push("}");
    lines.push("");
  }

  lines.push("export interface MicroCMSEndpointMap {");
  for (const item of endpointMap) {
    lines.push(`  ${JSON.stringify(item.endpoint)}: ${item.typeName};`);
  }
  lines.push("}");
  lines.push("");
  lines.push("export type MicroCMSEndpoint = keyof MicroCMSEndpointMap;");
  lines.push("export type MicroCMSContent<E extends MicroCMSEndpoint> = MicroCMSEndpointMap[E];");
  lines.push("");

  return {
    code: lines.join("\n"),
    endpointCount: endpointMap.length,
    warnings,
  };
}

function normalizeSchemas(input: unknown): NormalizedApiSchema[] {
  const fromBundle = tryExtractBundleSchemas(input);
  if (fromBundle.length > 0) {
    return dedupeSchemas(fromBundle);
  }

  const fromArray = Array.isArray(input)
    ? input
        .map((item): NormalizedApiSchema | null => {
          if (typeof item !== "object" || item === null) {
            return null;
          }

          const endpoint = extractEndpointName(item as ApiListItem);
          if (!endpoint) {
            return null;
          }

          return {
            endpoint,
            api: item,
          };
        })
        .filter((item): item is NormalizedApiSchema => item !== null)
    : [];

  if (fromArray.length > 0) {
    return dedupeSchemas(fromArray);
  }

  if (typeof input === "object" && input !== null) {
    const endpoint = extractEndpointName(input as ApiListItem);
    if (endpoint) {
      return [{ endpoint, api: input }];
    }
  }

  return [];
}

function tryExtractBundleSchemas(input: unknown): NormalizedApiSchema[] {
  if (typeof input !== "object" || input === null) {
    return [];
  }

  const asRecord = input as Record<string, unknown>;
  if (!Array.isArray(asRecord.apis)) {
    return [];
  }

  return asRecord.apis
    .map((item): NormalizedApiSchema | null => {
      if (typeof item !== "object" || item === null) {
        return null;
      }

      const endpoint = normalizeString((item as { endpoint?: unknown }).endpoint);
      if (!endpoint) {
        return null;
      }

      const api = (item as { api?: unknown }).api ?? item;
      return {
        endpoint,
        api,
      };
    })
    .filter((item): item is NormalizedApiSchema => item !== null);
}

function dedupeSchemas(items: NormalizedApiSchema[]): NormalizedApiSchema[] {
  const map = new Map<string, unknown>();

  for (const item of items) {
    map.set(item.endpoint, item.api);
  }

  return [...map.entries()]
    .map(([endpoint, api]) => ({ endpoint, api }))
    .sort((a, b) => a.endpoint.localeCompare(b.endpoint));
}

function extractApiListItems(data: unknown): ApiListItem[] {
  if (Array.isArray(data)) {
    return data.filter((item): item is ApiListItem => typeof item === "object" && item !== null);
  }

  if (typeof data !== "object" || data === null) {
    return [];
  }

  const asRecord = data as Record<string, unknown>;
  const candidates = [asRecord.contents, asRecord.apis, asRecord.items];

  for (const candidate of candidates) {
    if (Array.isArray(candidate)) {
      return candidate.filter(
        (item): item is ApiListItem => typeof item === "object" && item !== null,
      );
    }
  }

  return [];
}

function extractEndpointName(item: ApiListItem): string | null {
  const candidates = [item.endpoint, item.apiId, item.id];

  for (const candidate of candidates) {
    const endpoint = normalizeString(candidate);
    if (endpoint) {
      return endpoint;
    }
  }

  return null;
}

function extractApiFields(data: unknown): ApiField[] {
  if (typeof data !== "object" || data === null) {
    return [];
  }

  const asRecord = data as Record<string, unknown>;
  const candidates = [asRecord.apiFields, asRecord.fields, asRecord.customFields];

  for (const candidate of candidates) {
    if (Array.isArray(candidate)) {
      return candidate.filter(
        (item): item is ApiField => typeof item === "object" && item !== null,
      );
    }
  }

  return [];
}

function inferTsType(field: ApiField): string {
  const allowedValues = extractAllowedValues(field);
  if (allowedValues.length > 0) {
    const union = allowedValues.map((value) => JSON.stringify(value)).join(" | ");
    if (isFieldMultiple(field)) {
      return `(${union})[]`;
    }

    return union;
  }

  const hint =
    normalizeKind(field.type) ?? normalizeKind(field.fieldType) ?? normalizeKind(field.inputType);
  const fromHint = mapKindToType(hint, field);
  if (fromHint) {
    return fromHint;
  }

  const fromKind = mapKindToType(normalizeKind(field.kind), field);
  if (fromKind) {
    return fromKind;
  }

  return "unknown";
}

function mapKindToType(kind: string | null, field: ApiField): string | null {
  if (!kind) {
    return null;
  }

  switch (kind) {
    case "string":
    case "text":
    case "textarea":
    case "richtext":
    case "richeditor":
    case "wysiwyg":
    case "date":
    case "datetime":
    case "time":
    case "slug":
    case "url":
    case "radio":
    case "image":
    case "media":
    case "file":
      return "string";
    case "number":
    case "int":
    case "integer":
    case "float":
    case "double":
    case "decimal":
      return "number";
    case "boolean":
    case "bool":
    case "switch":
    case "checkbox":
      return "boolean";
    case "array":
    case "list":
    case "repeater":
      return "unknown[]";
    case "group":
    case "object":
      return "Record<string, unknown>";
    case "select":
      return isFieldMultiple(field) ? "string[]" : "string";
    case "relation":
      return isFieldMultiple(field) ? "string[]" : "string";
    default:
      return null;
  }
}

function extractAllowedValues(field: ApiField): string[] {
  const candidates = [field.selectItems, field.options];

  for (const candidate of candidates) {
    if (!Array.isArray(candidate)) {
      continue;
    }

    const values = candidate
      .map((item) => {
        if (typeof item === "string") {
          return item;
        }

        if (typeof item === "object" && item !== null) {
          const value =
            (item as { value?: unknown; id?: unknown }).value ?? (item as { id?: unknown }).id;
          return normalizeString(value);
        }

        return null;
      })
      .filter((value): value is string => value !== null);

    if (values.length > 0) {
      return [...new Set(values)];
    }
  }

  return [];
}

function isFieldRequired(field: ApiField): boolean {
  return Boolean(field.required);
}

function isFieldMultiple(field: ApiField): boolean {
  return Boolean(field.multiple) || Boolean(field.isMultiple);
}

function normalizeString(value: unknown): string | null {
  if (typeof value !== "string") {
    return null;
  }

  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function normalizeKind(value: unknown): string | null {
  if (typeof value !== "string") {
    return null;
  }

  const normalized = value
    .trim()
    .toLowerCase()
    .replace(/[\s_-]/g, "");
  return normalized.length > 0 ? normalized : null;
}

function toPascalCase(value: string): string {
  const segments = value
    .split(/[^A-Za-z0-9]+/)
    .map((segment) => segment.trim())
    .filter((segment) => segment.length > 0)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1));

  const joined = segments.join("");
  if (joined.length === 0) {
    return "Api";
  }

  if (/^[0-9]/.test(joined)) {
    return `Api${joined}`;
  }

  return joined;
}

function uniqueTypeName(base: string, used: Set<string>): string {
  if (!used.has(base)) {
    return base;
  }

  for (let i = 2; i < 10_000; i += 1) {
    const candidate = `${base}${i}`;
    if (!used.has(candidate)) {
      return candidate;
    }
  }

  return `${base}X`;
}

function isTsIdentifier(value: string): boolean {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(value);
}
