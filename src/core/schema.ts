import { extractAllowedValues, extractApiFields, normalizeKind } from "./api-field-utils.js";

export type SchemaBundle = {
  version: "0.x";
  pulledAt: string;
  serviceDomain: string | null;
  apis: Array<{
    endpoint: string;
    api: unknown;
  }>;
};

type ApiListItem = {
  endpoint?: unknown;
  apiId?: unknown;
  id?: unknown;
};

type ApiField = {
  fieldId?: unknown;
  required?: unknown;
  kind?: unknown;
  type?: unknown;
  fieldType?: unknown;
  inputType?: unknown;
  multiple?: unknown;
  isMultiple?: unknown;
  selectItems?: unknown;
  options?: unknown;
};

type NormalizedApiSchema = {
  endpoint: string;
  api: unknown;
};

export type GeneratedTypesResult = {
  code: string;
  endpointCount: number;
  warnings: string[];
};

export type SchemaFieldSnapshot = {
  fieldId: string;
  kind: string | null;
  required: boolean;
  allowedValues: string[];
};

export type SchemaFieldChange = {
  key: "kind" | "required" | "allowedValues";
  before: string | boolean | string[] | null;
  after: string | boolean | string[] | null;
};

export type SchemaFieldDiff = {
  fieldId: string;
  changes: SchemaFieldChange[];
  before: SchemaFieldSnapshot;
  after: SchemaFieldSnapshot;
};

export type SchemaEndpointDiff = {
  endpoint: string;
  added: string[];
  removed: string[];
  changed: SchemaFieldDiff[];
};

export type SchemaDiffResult = {
  hasDiff: boolean;
  summary: {
    endpointsAdded: number;
    endpointsRemoved: number;
    fieldsAdded: number;
    fieldsRemoved: number;
    fieldsChanged: number;
  };
  endpointsAdded: string[];
  endpointsRemoved: string[];
  endpoints: SchemaEndpointDiff[];
};

export function buildSchemaBundle(params: {
  serviceDomain?: string;
  apis: Array<{ endpoint: string; api: unknown }>;
}): SchemaBundle {
  return {
    version: "0.x",
    pulledAt: new Date().toISOString(),
    serviceDomain: params.serviceDomain ?? null,
    apis: params.apis,
  };
}

export function extractApiEndpoints(data: unknown): string[] {
  const items = extractApiListItems(data);
  const endpoints = items
    .map((item) => extractEndpointName(item))
    .filter((value): value is string => value !== null);

  return [...new Set(endpoints)].sort((a, b) => a.localeCompare(b));
}

export function diffSchemaBundles(baselineInput: unknown, currentInput: unknown): SchemaDiffResult {
  const baselineSchemas = normalizeSchemas(baselineInput);
  const currentSchemas = normalizeSchemas(currentInput);
  const baselineMap = new Map(baselineSchemas.map((item) => [item.endpoint, item.api]));
  const currentMap = new Map(currentSchemas.map((item) => [item.endpoint, item.api]));

  const baselineEndpoints = [...baselineMap.keys()].sort((a, b) => a.localeCompare(b));
  const currentEndpoints = [...currentMap.keys()].sort((a, b) => a.localeCompare(b));

  const endpointsAdded = currentEndpoints.filter((endpoint) => !baselineMap.has(endpoint));
  const endpointsRemoved = baselineEndpoints.filter((endpoint) => !currentMap.has(endpoint));
  const commonEndpoints = currentEndpoints.filter((endpoint) => baselineMap.has(endpoint));

  const endpointDiffs = commonEndpoints
    .map((endpoint) => {
      const baselineFields = buildComparableFieldMap(baselineMap.get(endpoint));
      const currentFields = buildComparableFieldMap(currentMap.get(endpoint));
      return diffEndpointFields(endpoint, baselineFields, currentFields);
    })
    .filter(
      (entry) => entry.added.length > 0 || entry.removed.length > 0 || entry.changed.length > 0,
    );

  const summary = {
    endpointsAdded: endpointsAdded.length,
    endpointsRemoved: endpointsRemoved.length,
    fieldsAdded: endpointDiffs.reduce((sum, entry) => sum + entry.added.length, 0),
    fieldsRemoved: endpointDiffs.reduce((sum, entry) => sum + entry.removed.length, 0),
    fieldsChanged: endpointDiffs.reduce((sum, entry) => sum + entry.changed.length, 0),
  };

  const hasDiff =
    endpointsAdded.length > 0 || endpointsRemoved.length > 0 || endpointDiffs.length > 0;

  return {
    hasDiff,
    summary,
    endpointsAdded,
    endpointsRemoved,
    endpoints: endpointDiffs,
  };
}

export function generateTypesFromSchema(input: unknown): GeneratedTypesResult {
  const schemas = normalizeSchemas(input);
  const warnings: string[] = [];

  const lines: string[] = [];
  lines.push("/* eslint-disable */");
  lines.push("/**");
  lines.push(" * Generated by mcms-cli types generate");
  lines.push(" * Do not edit manually.");
  lines.push(" */");
  lines.push("");

  const endpointMap: Array<{ endpoint: string; typeName: string }> = [];
  const usedTypeNames = new Set<string>();

  for (const schema of schemas) {
    const typeName = uniqueTypeName(`${toPascalCase(schema.endpoint)}Content`, usedTypeNames);
    usedTypeNames.add(typeName);
    endpointMap.push({ endpoint: schema.endpoint, typeName });

    const fields = extractApiFields(schema.api) as ApiField[];
    if (fields.length === 0) {
      warnings.push(`No fields found for endpoint: ${schema.endpoint}`);
    }

    lines.push(`export interface ${typeName} {`);
    lines.push("  id?: string;");

    const seenFields = new Set<string>();
    for (const field of fields) {
      const fieldId = normalizeString(field.fieldId);
      if (!fieldId) {
        continue;
      }

      if (seenFields.has(fieldId)) {
        continue;
      }
      seenFields.add(fieldId);

      const propertyName = isTsIdentifier(fieldId) ? fieldId : JSON.stringify(fieldId);
      const optional = isFieldRequired(field) ? "" : "?";
      const propertyType = inferTsType(field);
      lines.push(`  ${propertyName}${optional}: ${propertyType};`);
    }

    lines.push("}");
    lines.push("");
  }

  lines.push("export interface MicroCMSEndpointMap {");
  for (const item of endpointMap) {
    lines.push(`  ${JSON.stringify(item.endpoint)}: ${item.typeName};`);
  }
  lines.push("}");
  lines.push("");
  lines.push("export type MicroCMSEndpoint = keyof MicroCMSEndpointMap;");
  lines.push("export type MicroCMSContent<E extends MicroCMSEndpoint> = MicroCMSEndpointMap[E];");
  lines.push("");

  return {
    code: lines.join("\n"),
    endpointCount: endpointMap.length,
    warnings,
  };
}

function normalizeSchemas(input: unknown): NormalizedApiSchema[] {
  const fromBundle = tryExtractBundleSchemas(input);
  if (fromBundle.length > 0) {
    return dedupeSchemas(fromBundle);
  }

  const fromArray = Array.isArray(input)
    ? input
        .map((item): NormalizedApiSchema | null => {
          if (typeof item !== "object" || item === null) {
            return null;
          }

          const endpoint = extractEndpointName(item as ApiListItem);
          if (!endpoint) {
            return null;
          }

          return {
            endpoint,
            api: item,
          };
        })
        .filter((item): item is NormalizedApiSchema => item !== null)
    : [];

  if (fromArray.length > 0) {
    return dedupeSchemas(fromArray);
  }

  if (typeof input === "object" && input !== null) {
    const endpoint = extractEndpointName(input as ApiListItem);
    if (endpoint) {
      return [{ endpoint, api: input }];
    }
  }

  return [];
}

function buildComparableFieldMap(input: unknown): Map<string, SchemaFieldSnapshot> {
  const fields = extractApiFields(input) as ApiField[];
  const map = new Map<string, SchemaFieldSnapshot>();

  for (const field of fields) {
    const fieldId = normalizeString(field.fieldId);
    if (!fieldId) {
      continue;
    }

    const kind =
      normalizeKind(field.type) ??
      normalizeKind(field.fieldType) ??
      normalizeKind(field.inputType) ??
      normalizeKind(field.kind);
    const allowedValues = extractAllowedValues(field).sort((a, b) => a.localeCompare(b));

    map.set(fieldId, {
      fieldId,
      kind,
      required: Boolean(field.required),
      allowedValues,
    });
  }

  return map;
}

function diffEndpointFields(
  endpoint: string,
  baselineFields: Map<string, SchemaFieldSnapshot>,
  currentFields: Map<string, SchemaFieldSnapshot>,
): SchemaEndpointDiff {
  const baselineIds = [...baselineFields.keys()].sort((a, b) => a.localeCompare(b));
  const currentIds = [...currentFields.keys()].sort((a, b) => a.localeCompare(b));
  const added = currentIds.filter((fieldId) => !baselineFields.has(fieldId));
  const removed = baselineIds.filter((fieldId) => !currentFields.has(fieldId));

  const changed = currentIds
    .filter((fieldId) => baselineFields.has(fieldId))
    .map((fieldId) => {
      const before = baselineFields.get(fieldId);
      const after = currentFields.get(fieldId);
      if (!before || !after) {
        return null;
      }

      const changes: SchemaFieldChange[] = [];
      if (before.kind !== after.kind) {
        changes.push({ key: "kind", before: before.kind, after: after.kind });
      }
      if (before.required !== after.required) {
        changes.push({ key: "required", before: before.required, after: after.required });
      }
      if (!isStringArrayEqual(before.allowedValues, after.allowedValues)) {
        changes.push({
          key: "allowedValues",
          before: before.allowedValues,
          after: after.allowedValues,
        });
      }

      if (changes.length === 0) {
        return null;
      }

      return {
        fieldId,
        changes,
        before,
        after,
      };
    })
    .filter((entry): entry is SchemaFieldDiff => entry !== null);

  return {
    endpoint,
    added,
    removed,
    changed,
  };
}

function tryExtractBundleSchemas(input: unknown): NormalizedApiSchema[] {
  if (typeof input !== "object" || input === null) {
    return [];
  }

  const asRecord = input as Record<string, unknown>;
  if (!Array.isArray(asRecord.apis)) {
    return [];
  }

  return asRecord.apis
    .map((item): NormalizedApiSchema | null => {
      if (typeof item !== "object" || item === null) {
        return null;
      }

      const endpoint = normalizeString((item as { endpoint?: unknown }).endpoint);
      if (!endpoint) {
        return null;
      }

      const api = (item as { api?: unknown }).api ?? item;
      return {
        endpoint,
        api,
      };
    })
    .filter((item): item is NormalizedApiSchema => item !== null);
}

function dedupeSchemas(items: NormalizedApiSchema[]): NormalizedApiSchema[] {
  const map = new Map<string, unknown>();

  for (const item of items) {
    map.set(item.endpoint, item.api);
  }

  return [...map.entries()]
    .map(([endpoint, api]) => ({ endpoint, api }))
    .sort((a, b) => a.endpoint.localeCompare(b.endpoint));
}

function extractApiListItems(data: unknown): ApiListItem[] {
  if (Array.isArray(data)) {
    return data.filter((item): item is ApiListItem => typeof item === "object" && item !== null);
  }

  if (typeof data !== "object" || data === null) {
    return [];
  }

  const asRecord = data as Record<string, unknown>;
  const candidates = [asRecord.contents, asRecord.apis, asRecord.items];

  for (const candidate of candidates) {
    if (Array.isArray(candidate)) {
      return candidate.filter(
        (item): item is ApiListItem => typeof item === "object" && item !== null,
      );
    }
  }

  return [];
}

function extractEndpointName(item: ApiListItem): string | null {
  const candidates = [item.endpoint, item.apiId, item.id];

  for (const candidate of candidates) {
    const endpoint = normalizeString(candidate);
    if (endpoint) {
      return endpoint;
    }
  }

  return null;
}

function inferTsType(field: ApiField): string {
  const allowedValues = extractAllowedValues(field);
  if (allowedValues.length > 0) {
    const union = allowedValues.map((value) => JSON.stringify(value)).join(" | ");
    if (isFieldMultiple(field)) {
      return `(${union})[]`;
    }

    return union;
  }

  const hint =
    normalizeKind(field.type) ?? normalizeKind(field.fieldType) ?? normalizeKind(field.inputType);
  const fromHint = mapKindToType(hint, field);
  if (fromHint) {
    return fromHint;
  }

  const fromKind = mapKindToType(normalizeKind(field.kind), field);
  if (fromKind) {
    return fromKind;
  }

  return "unknown";
}

function mapKindToType(kind: string | null, field: ApiField): string | null {
  if (!kind) {
    return null;
  }

  switch (kind) {
    case "string":
    case "text":
    case "textarea":
    case "richtext":
    case "richeditor":
    case "wysiwyg":
    case "date":
    case "datetime":
    case "time":
    case "slug":
    case "url":
    case "radio":
    case "image":
    case "media":
    case "file":
      return "string";
    case "number":
    case "int":
    case "integer":
    case "float":
    case "double":
    case "decimal":
      return "number";
    case "boolean":
    case "bool":
    case "switch":
    case "checkbox":
      return "boolean";
    case "array":
    case "list":
    case "repeater":
      return "unknown[]";
    case "group":
    case "object":
      return "Record<string, unknown>";
    case "select":
      return isFieldMultiple(field) ? "string[]" : "string";
    case "relation":
      return isFieldMultiple(field) ? "string[]" : "string";
    default:
      return null;
  }
}

function isFieldRequired(field: ApiField): boolean {
  return Boolean(field.required);
}

function isFieldMultiple(field: ApiField): boolean {
  return Boolean(field.multiple) || Boolean(field.isMultiple);
}

function normalizeString(value: unknown): string | null {
  if (typeof value !== "string") {
    return null;
  }

  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : null;
}

function toPascalCase(value: string): string {
  const segments = value
    .split(/[^A-Za-z0-9]+/)
    .map((segment) => segment.trim())
    .filter((segment) => segment.length > 0)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1));

  const joined = segments.join("");
  if (joined.length === 0) {
    return "Api";
  }

  if (/^[0-9]/.test(joined)) {
    return `Api${joined}`;
  }

  return joined;
}

function uniqueTypeName(base: string, used: Set<string>): string {
  if (!used.has(base)) {
    return base;
  }

  for (let i = 2; i < 10_000; i += 1) {
    const candidate = `${base}${i}`;
    if (!used.has(candidate)) {
      return candidate;
    }
  }

  return `${base}X`;
}

function isTsIdentifier(value: string): boolean {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(value);
}

function isStringArrayEqual(a: string[], b: string[]): boolean {
  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i += 1) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}
